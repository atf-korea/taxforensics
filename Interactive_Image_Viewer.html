<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>평면도 뷰어 (로컬 업로드 및 회전 기능 포함)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the app */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
        }
        #image-container {
            cursor: grab;
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Hide overflow of the image when scaled/dragged */
            background-color: #ffffff;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        #floorplan-image {
            width: 100%;
            height: auto;
            /* transform-origin: center center; is already in the transform CSS, but explicitly setting here for consistency */
            transform-origin: center center; 
            transition: transform 0.1s ease-out;
            user-select: none;
            will-change: transform;
        }
        /* Make the main container scrollable if needed */
        .app-main {
            max-height: 100vh;
            overflow-y: auto;
            padding: 1rem;
        }
    </style>
</head>
<body>

    <div class="flex flex-col items-center justify-start w-full h-screen app-main">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 mt-8">평면도 이미지 뷰어</h1>

        <!-- Image Load Controls -->
        <div class="w-full max-w-4xl mb-4 p-4 bg-white rounded-xl shadow-lg flex flex-col space-y-4">
            
            <!-- URL Load -->
            <div class="flex flex-col md:flex-row space-y-3 md:space-y-0 md:space-x-3 items-center">
                <input type="url" id="image-url-input" 
                       class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" 
                       placeholder="여기에 이미지 URL을 입력하세요 (예: https://placehold.co/800x600)">
                <button onclick="loadImageFromUrl()" 
                        class="w-full md:w-auto px-6 py-3 text-base bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow-md transition duration-150 transform hover:scale-105">
                    URL에서 이미지 로드
                </button>
            </div>
            
            <!-- Local File Upload -->
            <div class="flex flex-col md:flex-row space-y-3 md:space-y-0 md:space-x-3 items-center pt-3 border-t border-gray-100">
                <input type="file" id="local-file-input" accept="image/*" class="hidden" onchange="loadImageFromLocal(event)">
                <label for="local-file-input" class="flex-grow p-3 border border-gray-300 rounded-lg bg-green-500 text-white font-semibold cursor-pointer text-center hover:bg-green-600 transition duration-150 transform hover:scale-[1.02]">
                    로컬 파일 선택 및 로드 (.png, .jpg)
                </label>
            </div>
        </div>


        <!-- Image Container for Pan and Zoom -->
        <div id="image-container" class="w-full max-w-4xl h-[60vh] md:h-[65vh] rounded-xl border-4 border-gray-200 overflow-hidden">
            <!-- Initial image uses the uploaded file -->
            <img id="floorplan-image" src="uploaded:image.png-8b0795ed-ec86-431b-9aa5-0761b2f38363" alt="3D 평면도 이미지">
        </div>

        <!-- Zoom/Pan/Rotation Controls -->
        <div class="flex flex-wrap justify-center space-x-3 space-y-3 md:space-y-0 mt-6 p-4 bg-white rounded-xl shadow-lg">
            <!-- Rotation Controls -->
            <button onclick="rotateLeft()" class="p-3 text-lg bg-yellow-500 hover:bg-yellow-600 text-white font-semibold rounded-lg shadow-md transition duration-150 transform hover:scale-105">
                <span class="text-xl">↺</span> 좌회전
            </button>
            <button onclick="rotateRight()" class="p-3 text-lg bg-yellow-500 hover:bg-yellow-600 text-white font-semibold rounded-lg shadow-md transition duration-150 transform hover:scale-105">
                <span class="text-xl">↻</span> 우회전
            </button>
            
            <!-- Zoom Controls -->
            <button onclick="zoomIn()" class="p-3 text-lg bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg shadow-md transition duration-150 transform hover:scale-105">
                확대 (+)
            </button>
            <button onclick="zoomOut()" class="p-3 text-lg bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg shadow-md transition duration-150 transform hover:scale-105">
                축소 (-)
            </button>
            
            <!-- Reset Control -->
            <button onclick="resetView()" class="p-3 text-lg bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg shadow-md transition duration-150 transform hover:scale-105">
                전체 초기화
            </button>
        </div>

        <p id="message-box" class="text-sm text-gray-500 mt-4 mb-8">
            마우스 왼쪽 버튼으로 이동하고, 오른쪽 버튼으로 드래그하여 회전할 수 있습니다.
        </p>
    </div>

    <script>
        const imageContainer = document.getElementById('image-container');
        const floorplanImage = document.getElementById('floorplan-image');
        const messageBox = document.getElementById('message-box');
        const imageUrlInput = document.getElementById('image-url-input');
        
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let rotation = 0; // Image rotation angle in degrees
        let isDragging = false; // For panning (left click)
        let isRotating = false; // For rotation (right click)
        let startX, startY; // For panning start coordinates
        let lastRotateX; // For rotation tracking
        let originalImageSrc = "uploaded:image.png-8b0795ed-ec86-431b-9aa5-0761b2f38363";

        // --- Utility function for displaying messages ---
        const displayMessage = (text, isError = false) => {
            messageBox.textContent = text;
            messageBox.className = 'text-sm mt-4 mb-8 ' + (isError ? 'text-red-600 font-semibold' : 'text-gray-500');
        };
        
        // Helper: Resets only pan (translation)
        const resetPan = () => {
            translateX = 0;
            translateY = 0;
        }

        // --- View Manipulation Functions ---

        const updateTransform = () => {
            // Apply scale, translation, and rotation via CSS transform
            floorplanImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale}) rotate(${rotation}deg)`;
            // Change cursor when zoomed in
            imageContainer.style.cursor = scale > 1 ? (isRotating ? 'crosshair' : 'grab') : 'default';
        };

        const zoomIn = () => {
            scale = Math.min(scale + 0.2, 5); // Max zoom level 5
            updateTransform();
        };

        const zoomOut = () => {
            scale = Math.max(scale - 0.2, 1); // Min zoom level 1
            
            // Recalculate and constrain translation after zooming out
            if (scale === 1) {
                resetPan(); // Reset pan when fully zoomed out
            } else {
                const containerRect = imageContainer.getBoundingClientRect();
                const imgWidth = floorplanImage.offsetWidth * scale;
                const imgHeight = floorplanImage.offsetHeight * scale;
                const maxTx = Math.max(0, (imgWidth - containerRect.width) / 2);
                const maxTy = Math.max(0, (imgHeight - containerRect.height) / 2);

                translateX = Math.min(Math.max(translateX, -maxTx), maxTx);
                translateY = Math.min(Math.max(translateY, -maxTy), maxTy);
            }
            
            updateTransform();
        };

        const rotateLeft = () => {
            rotation = (rotation - 90) % 360;
            if (rotation < 0) rotation += 360;
            resetPan(); // Reset pan when rotating to center the view
            updateTransform();
        };

        const rotateRight = () => {
            rotation = (rotation + 90) % 360;
            resetPan(); // Reset pan when rotating to center the view
            updateTransform();
        };


        const resetView = () => {
            scale = 1;
            rotation = 0; // Reset rotation
            resetPan(); // Reset translation
            updateTransform();
            displayMessage("마우스 왼쪽 버튼으로 이동하고, 오른쪽 버튼으로 드래그하여 회전할 수 있습니다.");
        };

        // --- Image Loading Functions (No change here) ---

        const loadImageFromUrl = () => {
            const url = imageUrlInput.value.trim();
            if (!url) {
                displayMessage("이미지 URL을 입력해주세요.", true);
                return;
            }
            
            const previousSrc = floorplanImage.src;
            resetView(); 
            
            floorplanImage.onerror = () => {
                displayMessage("이미지 로드에 실패했습니다. 유효한 이미지 URL인지 확인하거나, 로컬 파일을 사용해보세요.", true);
                floorplanImage.src = previousSrc || originalImageSrc; 
                floorplanImage.onerror = null; 
                floorplanImage.onload = null;
            };
            
            floorplanImage.onload = () => {
                displayMessage("새 이미지가 성공적으로 로드되었습니다.");
                floorplanImage.onload = null; 
                floorplanImage.onerror = null; 
            }

            floorplanImage.src = url;
            displayMessage("URL 이미지를 로드하는 중...");
        };

        const loadImageFromLocal = (event) => {
            const file = event.target.files[0];
            if (!file || !file.type.startsWith('image/')) {
                displayMessage("이미지 파일(.png, .jpg 등)을 선택해야 합니다.", true);
                return;
            }

            displayMessage("로컬 이미지를 로드하는 중...");
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const newSrc = e.target.result;
                
                floorplanImage.onerror = () => {
                    displayMessage("로컬 이미지 로드에 실패했습니다.", true);
                    floorplanImage.onerror = null; 
                    floorplanImage.onload = null;
                };
                
                floorplanImage.onload = () => {
                    resetView(); 
                    displayMessage(`로컬 파일: "${file.name}"이(가) 성공적으로 로드되었습니다.`);
                    floorplanImage.onload = null;
                    floorplanImage.onerror = null;
                }

                floorplanImage.src = newSrc;
            };
            reader.onerror = () => {
                displayMessage("파일 리더 오류로 인해 로컬 이미지를 로드할 수 없습니다.", true);
            };
            reader.readAsDataURL(file);
        };


        // --- Drag/Pan Event Handlers (Mouse & Touch) ---

        const startDrag = (e) => {
            // Only Left Mouse button (e.button === 0) for pan
            if (e.button !== 0 || scale <= 1) return; 

            isDragging = true;
            // Get initial mouse/touch position
            startX = (e.touches ? e.touches[0].clientX : e.clientX) - translateX;
            startY = (e.touches ? e.touches[0].clientY : e.clientY) - translateY;
            imageContainer.style.cursor = 'grabbing';
            e.preventDefault();
        };

        const drag = (e) => {
            if (!isDragging) return;

            // Calculate new translation
            const currentX = e.touches ? e.touches[0].clientX : e.clientX;
            const currentY = e.touches ? e.touches[0].clientY : e.clientY;
            
            translateX = currentX - startX;
            translateY = currentY - startY;

            // Implement boundary checks (Pan Limiter)
            const containerRect = imageContainer.getBoundingClientRect();
            // Note: Bounding box size changes with rotation, but we use simplified boundaries based on unrotated size for simple pan clamping.
            const imgWidth = floorplanImage.offsetWidth * scale;
            const imgHeight = floorplanImage.offsetHeight * scale;

            const maxTx = Math.max(0, (imgWidth - containerRect.width) / 2);
            const maxTy = Math.max(0, (imgHeight - containerRect.height) / 2);

            translateX = Math.min(Math.max(translateX, -maxTx), maxTx);
            translateY = Math.min(Math.max(translateY, -maxTy), maxTy);

            updateTransform();
        };

        const endDrag = () => {
            isDragging = false;
            // Cursor update is handled by endInteraction
        };
        
        // --- Rotation Handlers (Mouse Only) ---
        
        const startRotate = (e) => {
            // Only Right Mouse button (e.button === 2) for rotation
            if (e.button !== 2) return;
            
            isRotating = true;
            lastRotateX = e.clientX;
            imageContainer.style.cursor = 'crosshair'; // Visual cue for rotation
            // We must prevent default on right-click to suppress the context menu
            e.preventDefault(); 
        };
        
        const rotate = (e) => {
            if (!isRotating) return;

            const deltaX = e.clientX - lastRotateX;
            
            // Adjust sensitivity for rotation
            const rotationSpeed = 0.4; 
            rotation += deltaX * rotationSpeed;
            
            // Keep rotation within 0 to 360 degrees
            rotation %= 360;
            if (rotation < 0) rotation += 360;

            lastRotateX = e.clientX;
            updateTransform();
        };
        
        const endRotate = () => {
            isRotating = false;
            // Cursor update is handled by endInteraction
        };

        const endInteraction = () => {
            if (isDragging) endDrag();
            if (isRotating) endRotate();
            
            // Update cursor state after interaction
            if (scale > 1 && !isDragging && !isRotating) {
                imageContainer.style.cursor = 'grab';
            } else if (scale <= 1 && !isDragging && !isRotating) {
                imageContainer.style.cursor = 'default';
            }
        };


        // --- Event Listeners ---
        
        // Combined Mouse Down handler
        imageContainer.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left click for Pan/Drag
                startDrag(e);
            } else if (e.button === 2) { // Right click for Rotate
                startRotate(e);
            }
        });

        // Combined Mouse Move handler
        imageContainer.addEventListener('mousemove', (e) => {
            if (isDragging) {
                drag(e);
            } else if (isRotating) {
                rotate(e);
            }
        });

        // Combined Mouse Up handler
        document.addEventListener('mouseup', endInteraction); // Use document to handle mouseup outside the container

        // Mouse Leave handler (stops any ongoing interaction)
        imageContainer.addEventListener('mouseleave', endInteraction);

        // Context menu prevention for right-click rotation
        imageContainer.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Touch Events (only pan)
        imageContainer.addEventListener('touchstart', startDrag, { passive: false });
        imageContainer.addEventListener('touchmove', drag, { passive: false });
        imageContainer.addEventListener('touchend', endInteraction);

        // Scroll (Zoom) Event
        imageContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        });

        // Initial view setup
        window.onload = updateTransform;
    </script>
</body>
</html>